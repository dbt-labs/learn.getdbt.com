---
layout: presentation
title: Sources
estimated_teaching_time: 30
teaching_method: live demo + slides. Questions encouraged.
working_session: true
learningObjectives:
  - Configure Sources
  - Build dependencies between sources and models
  - Configure tests for sources
  - Configure freshness snapshots
  - Build intuition for why defining sources can be helpful in the future
---

class: title, center, middle
# Sources

---

# If you've ever had this happen...

- I'm switching my email marketing platform. I want to know which final models depend on that source data.

--

- I'm switching from Redshift to Snowflake. All of my source data will be
in a different database and schema.

--

- Someone asked me "where does this data _really_ come from?"

--

- Nothing in this world is perfect. My data loading tools experience occasional
hiccups that result in delayed or duplicated data.

--

- Something that was once true about my source data is no longer true (e.g. a
new payment method was introduced)

???
Teaching Note: Think of a good story to share about a specific situation when dbt source functionality would have really helped avoid a painful mistake or burdensome work.


---

# Sources may be right for you!

- Easily declare and update the location of raw tables
    - `database` + `schema` for each source
    - `name`/`identifier` for each table
--
- Test data integrity of raw tables
    - Built-in: `unique`, `not_null`, `accepted_values`, `relationships`
    - Custom: whatever you want!
--
- Test the freshness of loaded data, based on thresholds you define

---

{% include options/focus_slide.html %}

---

# Defining sources
Sources are defined in `.yml` files in your `models/` directory.

(They can co-exist with `models:` blocks)

```yml
version: 2

sources:
  - name: jaffle_shop
    database: raw
    schema: jaffle_shop
    tables:
      - name: customers
        identifier: customers
      - name: orders
        identifier: orders

```
???
Demo: Jump into dbt cloud to walk through this source.yml in the IDE.

Note: Code in the project is different from on the slide. Slide contains schema and table identifiers - call this out as optional config that allow for more flexibility - giving you the chance to name a source something more appropriate than its given name in the db.

Teaching Note: In case anyone asks 'What does the 'version: 2' in all the yml file code snippets do? Can/should I update yml code versions?'. Answer: "Once upon a time, the structure of these .yml files was very different (s/o to anyone who was using dbt back then!). Adding version: 2 allowed us to make this structure more extensible." taken from dbt docs https://docs.getdbt.com/faqs/why-version-2
---

# Selecting from sources

Use the {% raw %}`{{ source() }}`{% endraw %} function to select from a source in a model:

.left-column[
{% raw %}
```sql
with source as (

    select * from {{ source('jaffle_shop', 'customers') }}

),

renamed as (

...
```
{% endraw %}
]
???
Demo: Open and talk through the use of source in model stg_customers. Press compile to demo how the source function gets compiled to the full object name.
--

.right-column[
```sql
with source as (

    select * from raw.jaffle_shop.customers

),

renamed as (

...
```
]

---

# Sources are rendered as green nodes
They help users understand where data comes from (lineage)

<img src="/ui/img{{page.id}}/dag-source.png" class="img-center">

???
Demo: Still on the stg_customers model, open the lineage tab and identify the source and model nodes.

---

# Testing sources

.denser-text[

You can add tests to sources! And you should!
]

.denser-text[
```yml
version: 2

sources:
  - name: jaffle_shop
    database: raw
    schema: jaffle_shop
    tables:
      - name: customers
        identifier: customers
        columns:
          - name: id
            tests:
              - not_null
              - unique
```
]

.denser-text[

Being thoughtful about where you test helps you understand whether tests are failing because:
- The assumptions about your source data are no longer true
- Or your SQL has changed

This allows you to debug more quickly!

]
???
Demo: While looking at the source yml ask the group what is being tested in this source (look for the table name, column name, and specific tests)

Ask group why it might be helpful to test sources in addition to testing models (transformed data). (Answer - faster troubleshooting!)
---

# Testing Sources

We can run tests on _only_ sources with the following command

`dbt test -s source:* `

This can be helpful in deployment - coming up soon

---


# Feeling fresh?

Optionally, specify a `loaded_at_field` and `freshness`:

.denser-text[

```yml
version: 2

sources:
  - name: jaffle_shop
    database: raw
    schema: jaffle_shop
    tables:
      - name: customers
        identifier: customers
      - name: orders
        identifier: orders
        loaded_at_field: _etl_loaded_at
        freshness:
          warn_after:
            count: 12
            period: hour
          error_after:
            count: 24
            period: hour

```

]

Then run `dbt source freshness`

???
Note: In order for source freshness testing to work as intended, it's imperative to have an accurate 'loaded_at' field. 

---
## Snapshotting freshness

.denser-text[
```yml
$ dbt source freshness
Running with dbt=0.16.0
Found 5 models, 20 tests, 0 snapshots, 0 analyses, 130 macros, 0 operations, 0 seed files, 3 sources

17:29:17 | Concurrency: 4 threads (target='learn')
17:29:17 |
17:29:17 | 1 of 1 START freshness of jaffle_shop.orders......................... [RUN]
17:29:20 | 1 of 1 WARN freshness of jaffle_shop.orders.......................... [WARN in 2.91s]
17:29:21 | Done.
```
]

### How does dbt check freshness?

--

.denser-text[
* dbt runs a SQL statement
{% raw %}
.left-column[
```sql
select
    max({{ loaded_at_field }}) as max_loaded_at,
    {{ current_timestamp() }} as snapshotted_at
from {{ source }}
```
{% endraw %}
]

.right-column[
```sql
select
    max(_batched_at) as max_loaded_at,
    convert_timezone('UTC', current_timestamp()) as snapshotted_at
from raw.stripe.payment
```
]
* Then it uses python to determine whether the delta is within the right range
]
---


.left-column-33[
## In dbt Cloud:

Adding this step to a job helps you understand if one of your data sources is out of date.

]

.right-column-66[
```bash
dbt source freshness
```
<img src="/ui/img{{page.id}}/freshness-viz.png" style="width: 100%;" class="img-center">
]
???
The dbt cloud source freshness page is accessable to dbt cloud developers but also to those with read-only seats - providing a friendly self service UI for stakeholders to check on the freshness of source data. (Which hopefully means fewer emails asking whether data from [insert your favorite/most problematic source system] is up to date in the BI tool.
---

# In deployment

A common approach: Test the schema integrity of raw tables _before_
replacing production models.

```bash
dbt test -s source:*            # ensure no duplicates or unexpected nulls -- the job won't continue if these tests fail
dbt run                         # only runs if test above succeeds
dbt test --exclude source:*     # or you can even skip these!
dbt source freshness   # powers freshness viz in dbt Cloud
```

Another option: `source freshness` first, so that your job won't run on stale data.

???
More complex deployments:
- Blue/green that renames schema/database at last step (if all tests pass) or
leaves old objects in place (if a test fails)

---

class: subtitle

## Checkpoint
Given the following YML file, what will the following select statements compile to?

.left-column[
`sources.yml`
```yml
version: 2

sources:
  - name: event_data
    database: raw
    schema: snowplow
    tables:
      - name: events
        identifier: snowplow_events
```
]

{% raw %}
.right-column[
`SQL`

```sql
select *
from {{ source('event_data', 'events') }}
```
]
{% endraw %}

---

class: subtitle

## Checkpoint
Given the following YML file, what will the following select statements compile to?

.left-column[
`sources.yml`
```yml
version: 2

sources:
  - name: payment_data
    database: raw
    schema: stripe
    tables:
      - name: payments
        identifier: stripe_payments
```
]

{% raw %}
.right-column[
`SQL`

```sql
select *
from {{ source('payment_data','payments') }}
```
]
{% endraw %}

---

class: subtitle

## Checkpoint

- How does using sources, instead of directly referencing tables, impact our work as analytics engineers?
 
--

## Questions??

---


class: subtitle

# Knowledge check

You should be able to:
* Define sources
* Select from a source in a model
* Add tests to a source
* Check the freshness of your source

{% include options/last_slide.html %}


---
## Further explorations

- (!!) I want to stage & query an external table that points to files in S3.

- (!!) Declare `external` properties ([read more](https://github.com/fishtown-analytics/dbt-external-tables))
