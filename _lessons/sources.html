---
layout: presentation
title: Sources
estimated_teaching_time: 30
teaching_method: live demo + slides. Questions encouraged.
working_session: true
learningObjectives:
  - Configure Sources
  - Build dependencies between sources and models
  - Configure tests for sources
  - Configure freshness snapshots
  - Build intuition for why defining sources can be helpful in the future
---

class: title, center, middle
# Sources

---

# If you've ever had this happen...

- I'm switching my email marketing platform. I want to know which final models depend on that source data.

--

- I'm switching from Redshift to Snowflake. All of my source data will be
in a different database and schema.

--

- Someone asked me "where does this data _really_ come from?"

--

- Nothing in this world is perfect. My data loading tools experience occasional
hiccups that result in delayed or duplicated data.

--

- Something that was once true about my source data is no longer true (e.g. a
new payment method was introduced)


---

# Sources may be right for you!

- Easily declare and update the location of raw tables
    - `database` + `schema` for each source
    - `name`/`identifier` for each table
--
- Test data integrity of raw tables
    - Built-in: `unique`, `not_null`, `accepted_values`, `relationships`
    - Custom: whatever you want!
--
- Test the freshness of loaded data, based on thresholds you define

---

{% include options/focus_slide.html %}

---

# Defining sources
Sources are defined in `.yml` files in your `models/` directory.

(They can co-exist with `models:` blocks)

```yml
version: 2

sources:
  - name: jaffle_shop
    database: raw
    schema: jaffle_shop
    tables:
      - name: customers
      - name: orders

```

---

# Selecting from sources

Use the {% raw %}`{{ source() }}`{% endraw %} function to select from a source in a model:

.left-column[
{% raw %}
```sql
with source as (

    select * from {{ source('jaffle_shop', 'customers') }}

),

renamed as (

...
```
{% endraw %}
]

--

.right-column[
```sql
with source as (

    select * from raw.jaffle_shop.customers

),

renamed as (

...
```
]

---

# Sources are rendered as green nodes
They help users understand where data comes from (lineage)

<img src="/ui/img{{page.id}}/dag-source.png" class="img-center">

---

# Testing sources

.denser-text[

You can add tests to sources! And you should!
]

.denser-text[
```yml
version: 2

sources:
  - name: jaffle_shop
    database: raw
    schema: jaffle_shop
    tables:
      - name: customers
        columns:
          - name: id
            tests:
              - not_null
              - unique
```
]

.denser-text[

Being thoughtful about where you test helps you understand whether tests are failing because:
- The assumptions about your source data are no longer true
- Or your SQL has changed

This allows you to debug more quickly!

]

---

# Testing Sources

We can run tests on _only_ sources with the following command

`dbt test -m source:* `

This can be helpful in deployment - coming up soon

---


# Feeling fresh?

Optionally, specify a `loaded_at_field` and `freshness`:

.denser-text[

```yml
version: 2

sources:
  - name: jaffle_shop
    database: raw
    schema: jaffle_shop
    tables:
      - name: customers
      - name: orders
        loaded_at_field: _etl_loaded_at
        freshness:
          warn_after:
            count: 12
            period: hour
          error_after:
            count: 24
            period: hour

```

]

Then run `dbt source snapshot-freshness`

---
## Snapshotting freshness

.denser-text[
```yml
$ dbt source snapshot-freshness
Running with dbt=0.16.0
Found 5 models, 20 tests, 0 snapshots, 0 analyses, 130 macros, 0 operations, 0 seed files, 3 sources

17:29:17 | Concurrency: 4 threads (target='learn')
17:29:17 |
17:29:17 | 1 of 1 START freshness of jaffle_shop.orders......................... [RUN]
17:29:20 | 1 of 1 WARN freshness of jaffle_shop.orders.......................... [WARN in 2.91s]
17:29:21 | Done.
```
]

### How does dbt check freshness?

--

.denser-text[
* dbt runs a SQL statement
{% raw %}
.left-column[
```sql
select
    max({{ loaded_at_field }}) as max_loaded_at,
    {{ current_timestamp() }} as snapshotted_at
from {{ source }}
```
{% endraw %}
]

.right-column[
```sql
select
    max(_batched_at) as max_loaded_at,
    convert_timezone('UTC', current_timestamp()) as snapshotted_at
from raw.stripe.payment
```
]
* Then it uses python to determine whether the delta is within the right range
]
---


.left-column-33[
## In dbt Cloud:

Adding this step to a job helps you understand if one of your data sources is out of date.

]

.right-column-66[
```bash
dbt source snapshot-freshness
```
<img src="/ui/img{{page.id}}/freshness-viz.png" style="width: 100%;" class="img-center">
]

---

# In deployment

A common approach: Test the schema integrity of raw tables _before_
replacing production models.

```bash
dbt test -m source:*            # ensure no duplicates or unexpected nulls -- the job won't continue if these tests fail
dbt run                         # only runs if test above succeeds
dbt test --exclude source:*     # or you can even skip these!
dbt source snapshot-freshness   # powers freshness viz in dbt Cloud
```

Another option: `snapshot-freshness` first, so that your job won't run on stale data.

???
More complex deployments:
- Blue/green that renames schema/database at last step (if all tests pass) or
leaves old objects in place (if a test fails)

---

class: subtitle

## Checkpoint
Given the following YML file, what will the following select statements compile to?

.left-column[
`sources.yml`
```yml
version: 2

sources:
  - name: event_data
    database: raw
    schema: snowplow
    tables:
      - name: events
```
]

{% raw %}
.right-column[
`SQL`

```sql
select *
from {{ source('event_data', 'events') }}
```
]
{% endraw %}

---

class: subtitle

## Checkpoint
Given the following YML file, what will the following select statements compile to?

.left-column[
`sources.yml`
```yml
version: 2

sources:
  - name: payment_data
    database: raw
    schema: stripe
    tables:
      - name: payments
```
]

{% raw %}
.right-column[
`SQL`

```sql
select *
from {{ source('payment_data','payments') }}
```
]
{% endraw %}

---

class: subtitle

## Checkpoint

- How does using sources, instead of directly referencing tables, impact our work as analytics engineers?
 
--

## Questions??

---


class: subtitle

# Knowledge check

You should be able to:
* Define sources
* Select from a source in a model
* Add tests to a source
* Check the freshness of your source

{% include options/last_slide.html %}


---
## Further explorations

- (!!) I want to stage & query an external table that points to files in S3.

- (!!) Declare `external` properties ([read more](https://github.com/fishtown-analytics/dbt-external-tables))
