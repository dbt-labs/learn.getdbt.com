---
layout: presentation
title: Testing
estimated_teaching_time: 30
teaching_method: live demo + slides. Questions encouraged.
working_session: true
learningObjectives:
  - Explain the role of tests in an analytics workflow
  - Add tests to your models
  - Run tests on your models
  - Build intuition for why tests fail and what to test

---
class: title, center, middle
# Testing
---

{% include options/focus_slide.html %}

---

# Refresher:

### The [dbt Viewpoint](https://docs.getdbt.com/docs/about/viewpoint/)
_**Analytics code should have quality assurance**_
* _Run automated tests on source data and on transformed data to ensure that SQL works as intended_
* _Ensure source data is up to date_

???
""  
Previously, we've given a broad overview of our viewpoints.  
Part of this viewpoint is our belief that our code should have quality  
assurance.  
  
To do this we need to be able to:  
""  
  
[Teacher Notes:]  
Read out bullet points on the slide  

---
# What are tests?

**Tests** are assertions you make about your **models**.

When your assertion is true, your tests pass.

You configure tests in YML, in the `models` directory.

Behind the scenes, test are just `select` statements!

???
""  
So, what do we mean when we're talking about testing?  
What we mean is that we want to ensure that when our assertions about our  
data is true, our tests pass.  
""  
  
[Teacher Notes:]  
Read the rest of the slide to give the broad overview of test implementation.  
---
# Examples:
.left-column[
```yml
version: 2

models:
  - name: customers
    columns:
      - name: customer_id
        tests:
          - not_null

```
]

???
""
We set up tests using our .yml configuration files. Here's an example
of a test which ensures that our customer_id key in our customers model is
not null.  
""  
  
[Teacher Notes:]  
You can pause here to exemplify this and the following slides in dbt Cloud  
for tests on uniqueness and not null. You should hit these points:  
  
- Setting up a not null test  
- Showing the underlying code after running the test using the run details.  
- Setting up a uniqueness test  
- Showing the underlying code after running the test using the run details.  
  
If you pause here for an example, you can start out with "So to recap:" for  
this and the following test examples.  
--
.right-column[
```sql

select
  count(*)

from analytics.customers
where customer_id is null

```

]

???
""  
Here's the underlying SQL that runs for the not_null test using results of our  
customers table. It returns number of records in our customers table where our  
customer_id is null, which will result in a failure if rows are returned.  
""  
  
[Teacher Notes:]  
Talk about how these relate.  
If you exemplified this, just do a quick recap.  
---

# Examples:
.left-column[
```yml
version: 2

models:
  - name: customers
    columns:
      - name: customer_id
        tests:
          - not_null
          - unique

```
]

???
""  
Now we're going to add test to our configuration to ensure that every customer_id  
in the customers table is unique.  
""  
  
[Teacher Notes:]  
If you exemplified this, just do a quick recap.  
--

.right-column[
```sql

select count(*) from (
  select
    customer_id

  from analytics.customers
  group by customer_id
  having count(*) > 1
)

```
]

???
""  
Here's the underlying code - you can see that it returns all customer_ids that  
have more than one record associated to that id. If any rows return, then the  
test fails.  
""  

[Teacher Notes:]  
If you exemplified this, just do a quick recap.  
---

# How do we run tests?

Run all tests: `dbt test`

Run specific tests: `dbt test -s one_specific_model`

???
""
After we've implemented our tests, how do we run them? We just need a command -
dbt test. If we wanted to only run tests for a specific model, we could use
selection syntax with -s to specify which model we want to test.
""

[------------------------------ Teacher Notes ---------------------------------]
You can exemplify this in dbt Cloud. If you've already exemplified this, just
give a recap here.
[------------------------------------------------------------------------------]

---

# What happens when you run `dbt test`?

1. dbt connection to your **data warehouse** (via a **profile/connection**)
2. dbt parses your **dbt project**
3. dbt iterates through the resource files (`models/**.yml`) to construct `select` queries.
4. dbt executes the SQL for each test: if the number `0` is returned your test passes

???
""
When we run dbt test, what happens under the hood?  
""

[------------------------------ Teacher Notes ---------------------------------]
Read the list items - you can expand on the parsing by saying that dbt 
collects all the configurations first and then executes, which means that you
can separate tests out by folder or you can keep all your tests in one big file.
Our best practice is to separate by folder. 

The other important piece here is that the dbt test operates on the result of a
number - count of 0 is a pass and anything more than 0 is a failure.
[------------------------------------------------------------------------------]

---

# dbt's built-in tests:
.left-column[
* **`unique`**
* `not_null`
* `accepted_values`
* `relationships`
]

.right-column[
Every value in this column is unique.


]

???
""
dbt come packages with four out-of-the-box tests. Unique, which as we saw tests
that each value in the specified column has no more than one row in the results.
""

[------------------------------ Teacher Notes ---------------------------------]

[------------------------------------------------------------------------------]

---
# dbt's built-in tests:
.left-column[
* `unique`
* **`not_null`**
* `accepted_values`
* `relationships`
]

.right-column[
Every value in this column is not null.


]

???
""
Not null, which tests that every value in the specified column has a value.
""

[------------------------------ Teacher Notes ---------------------------------]

[------------------------------------------------------------------------------]

---
# dbt's built-in tests:
.left-column[
* `unique`
* `not_null`
* **`accepted_values`**
* `relationships`
]

.right-column[
Every value in this column is a value from a given list.

```yml
version: 2

models:
  - name: stg_orders
    columns:
      - name: status
        tests:
          - accepted_values:
              values:
                - placed
                - shipped
                - completed
                - returned
```
]

???
""
Accepted values, which tests that the values in a column is one of the values in
a specified list.
""

[------------------------------ Teacher Notes ---------------------------------]

[------------------------------------------------------------------------------]

---
# dbt's built-in tests:
.left-column[
* `unique`
* `not_null`
* `accepted_values`
* **`relationships`**
]

.right-column[
Each value in this column exists in the column of another table.

```yml
version: 2

models:
  - name: stg_orders
    columns:
      - name: customer_id
        tests:
          - relationships:
              to: ref('stg_customers')
              field: customer_id

```

]

???
""
and relationships, which ensures referential integrity. In other words, it tests
that a column in your model has a related record in a different table.
""

[------------------------------ Teacher Notes ---------------------------------]

[------------------------------------------------------------------------------]

---
# Q: Why might a test fail?
--

1. The SQL in your model doesn’t do what you intended.

--

```sql
select
    orders.order_id,
    payments.payment_id
from orders
left join payments
    on orders.order_id = payments.order_id
```
```yml
models:
  - name: orders
    columns:
      - name: order_id
        tests:
          - unique
```

???
""
Now that we know how to implement and execute tests, let's go over some common
reasons why our tests might fail.
""

[------------------------------ Teacher Notes ---------------------------------]
Examples for this slide:
* Bad deduping
* The 1:many relationship between orders and payments in this example 
unexpectedly causes a fan out
[------------------------------------------------------------------------------]

---
# Q: Why might a test fail?

1. The SQL in your model doesn’t do what you intended.
2. An assumption about your source data is wrong.
--


```sql
select
    id as order_id,
    user_id as customer_id,
    order_date,
    status

from raw.jaffle_shop.orders
```
```yml
models:
  - name: stg_orders
    columns:
      - name: order_id
        tests:
          - unique
```

???
""
An assumption about your source data is wrong.
""

[------------------------------ Teacher Notes ---------------------------------]
Examples for this slide:
* You might assume that because a table is called "orders", for example, that the
order_id is unique identifier. It's great to always test these things - we've
been burned before!
[------------------------------------------------------------------------------]

---
# Q: Why might a test fail?

1. The SQL in your model doesn’t do what you intended.
2. An assumption about your source data is wrong.
    * non-unique IDs
    * 1:many instead of 1:1
    * Missing data
    * NULLs you weren't expecting

???
""
That means testing for things like non-unique IDs, cardinality, missing data, or
for nulls we don't expect.
""

[------------------------------ Teacher Notes ---------------------------------]

[------------------------------------------------------------------------------]

---
# Q: Why might a test fail?

1. The SQL in your model doesn’t do what you intended.
2. An assumption about your source data is wrong.

???
""
That means testing for things like non-unique IDs, cardinality, missing data, or
for nulls we don't expect.
""

[------------------------------ Teacher Notes ---------------------------------]

[------------------------------------------------------------------------------]

--
3. A previously-true assumption about your underlying source data is no longer true
--

    * A previously unique key is no longer unique
    * You have a new payment method

---
# Q: What should you test?
--

* Good rules of thumb:
    * Test primary keys (`unique`, `not_null`)
    * Test fields that you use in downstream models

---
# Q: When should you run tests?
--

* Manual: When you first run a project
* Manual: During development
* Automated: When you run dbt on a schedule
* Automated: When you want to merge your code

---

class: subtitle

## Checkpoint

.left-column[
```yml
version: 2

models:
  - name: payments
    columns:
      - name: payment_id
        tests:
          - not_null
          - unique
```
]

.right-column[
- What are the tests being run in this project?
- What are they running on?
- If they fail, what does that tell us?
]


---

class: subtitle

## Checkpoint

.left-column[
```yml
version: 2

models:
  - name: payments
    columns:
      - name: payment_method
        tests:
          - accepted_values:
              values:
                - credit_card
                - paypal
                - ach_transfer
```
]

.right-column[
- What are the tests being run in this project?
- What are they running on?
- If they fail, what does that tell us?
]

---

class: subtitle

# Knowledge check
You should be able to:
* Add tests to your models
* Run your tests (all of them / one model at a time)
* Explain how dbt tests work
* Find the compiled SQL for tests

{% include options/last_slide.html %}
