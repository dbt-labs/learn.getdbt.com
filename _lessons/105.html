---
layout: presentation
title: Testing & CI
lesson: 105
estimated_teaching_time: 30
teaching_method: live demo + slides. Questions encouraged.
working_session: true
---
class: title, center, middle
# Testing & CI
---

# Refresher:
--

## From 102: The Analytics Engineering Viewpoint
**Analytics code should have quality assurance**
* Run automated tests on source data and on transformed data to ensure that SQL works as intended
* Ensure source data is up to date

--

## From 103: dbt Fundamentals
**Tests** are assertions you make about your **models**.

When you execute the `test` **command** dbt iterates through the schema files (`models/**.yml`) to construct `select` queries.

These queries return `0` when your assertion is true, otherwise the test fails.
???
We've already touched on these concepts a couple of times.

---
# Examples:
.left-column[
```yml
version: 2

models:
  - name: customers
    columns:
      - name: customer_id
        tests:
          - not_null

```
]
--
.right-column[
```sql

select
  count(*)

from analytics.customers
where customer_id is null

```

]
???
Teacher notes: talk about how these relate
---
# Examples:
.left-column[
```yml
version: 2

models:
  - name: customers
    columns:
      - name: customer_id
        tests:
          - not_null
          - unique

```
]
--
.right-column[
```sql

select count(*) from (
  select
    customer_id

  from analytics.customers
  group by customer_id
  having count(*) > 1
)

```
]

---

# dbt's built-in tests:
* `unique`
* `not_null`
* `accepted_values`
* `relationships`

---
# Q: Why might a test fail?
--

1. The SQL in your model doesn’t do what you intended.

--

```sql
select
    customers.customer_id,
    customer_orders.number_of_orders
from customers

left join customer_orders using (customer_id)

```

```yml
version: 2

models:
  - name: customers
    columns:
      - name: number_of_orders
        tests:
          - not_null
```
--

```sql
select
    customers.customer_id,
    coalesce(customer_orders.number_of_orders, 0) as number_of_orders
from customers

left join customer_orders using (customer_id)
```
???
Examples:
* Bad deduping
* Bad joins

---
# Q: Why might a test fail?

1. The SQL in your model doesn’t do what you intended
--

2. An assumption about your source data is wrong.

--
    * non-unique IDs
    * Missing data
    * NULLs you weren't expecting

---
# Q: Why might a test fail?

1. The SQL in your model doesn’t do what you intended.
2. An assumption about your source data is wrong.

--
3. A previously-true assumption about your underlying source data is no longer true
--

    * A previously unique key is no longer unique
    * You have a new payment method

---
# Q: What should you test?
--

* Good rules of thumb:
    * Test primary keys (`unique`, `not_null`)
    * Test fields that you use in downstream models

---
# Q: When should you run tests?
--

* Manual: When you first run a project
* Manual: During development
* Automated: When you run dbt on a schedule
* Automated: When you want to merge your code

--

Wait, how do I automate running dbt?
---
# Running dbt in production
* You need to run dbt on a schedule to keep your data up to date
* These production runs should always use the latest version of your dbt project → **continuous deployment**
* You should have a way to know if something goes wrong (monitoring + alerting) and ways to debug what went wrong (logs and artifacts)
* You should automate a build + test your code  every time you want to merge changes (or "deploy to production") →  **continuous integration**

We use the scheduler in [dbt Cloud](cloud.getdbt.com) to run dbt in production.

---
name:working-session

# Working session
* Ensure that your (new) `orders` model has tests on it
