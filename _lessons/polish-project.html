---
layout: presentation
title: Polish your dbt project
estimated_teaching_time: 45
estimated_working_session: 0
teaching_method: 15 minutes for recap at start. 30 minutes of one-sided lecture
learningObjectives:
  - Develop a mental checklist for polishing your project before sharing your code

---
class: title, center, middle
# Polish your dbt project

???
[Teacher Notes]:  
A list of hot-tips that will take your project from good to great! The  
aim here is to pause a bit on fundamentals to talk about best practices and  
the do's and dont's of utilizing the functionality we've learned about so far.  
---

{% include options/focus_slide.html %}

---

class: subtitle
# dbt code

???
""  
First we'll talk about dbt code  
""  
--

i.e. the code in your `.sql` and `.yml` files

???
""  
This means the content of your .sql and .yml files.  
""  

---


## Require a dbt version to prevent conflicts
_(Also, you can remove the comments that were generated by the `init` command)_

.dense-text[

```yml
# dbt_project.yml
require-dbt-version: [">=0.17.1", "<0.19.0"]
```

]
.caption[
    [Source](https://github.com/fishtown-analytics/dbt-init/blob/master/starter-project/dbt_project.yml)
]

Use this to frequently update your dbt version for your team.

Note - You can follow dbt releases on GitHub:

[github.com/fishtown-analytics/dbt/releases](https://github.com/fishtown-analytics/dbt/releases)

???
[Teacher Notes:]  
You can take a moment here to exemplify what happens when you add this config.  
You should hit these points:  
- How does a dbt run function when your version is within the requirements?
- How does a dbt run function when your version is out of the requirements?
  
You'll need to click on the status in the bottom right corner and scroll all  
the way down the error message to see the message where the version doesn't  
meet the requirements.  
  
""  
Pin yourself to a version - in our dbt_project.yml, we can set a configuration  
to do this called `require-dbt-version`. In our example, our project works with  
versions later than or equal to 0.17.1 and less than 0.19.0. By requiring this,  
you ensure that the functionality used in the project works as expected and is  
available for anyone trying to running it. This is more important for CLI users,  
as the dbt Cloud development environment (which we'll learn about later) sets  
the version that developers will use across the board.  
""  

---
## Ensure you don't have any direct table references
--

üôÖ‚Äç‚ôÄÔ∏è
```sql
select * from dbt_claire.stg_customers
```

???
""  
We don't want any direct schema references here - as we learned about in earlier  
lessons, if we explicitly refer to the schema like this, then anyone else  
pulling your code will need to change the schema reference to refer to the  
things in their own development schema.  
""  
--

üôÖ‚Äç‚ôÄÔ∏è
{% raw %}
```sql
select * from {{ target.schema }}.stg_customers
```

???
""  
We also don't want this - using the target context to identify the schema.  
This will work because it's looking at your profile setup and schema that you  
defined, but it won't properly identify the lineage that needs to happen for  
our dbt runs, which will result in things running out of order and missing  
dependencies in our DAG.  
""  
--

üôÜ‚Äç‚ôÄÔ∏è
```sql
select * from {{ ref('stg_customers') }}
```
???
""  
You always want to use the ref() function to refer to other models in your  
project! This is the atomic unit of dbt - it identifies the correct order that  
your models should run in and allows you to efficiently see dependencies and  
injections for better informed modeling decisions.  
""  

---
## Ensure you don't have any direct table references
--

üôÖ‚Äç‚ôÄÔ∏è
```sql
select * from raw.jaffle_shop.customers
```

???
""  
The same goes for sources of data - you shouldn't hardcode the raw data  
reference. By explicitly stating this, you're not centralizing your  
configuration for your data sources. If there's a change in where the data lives  
(it happens!), you'll need to go through all of your files and change the  
reference vs. going to one configuration file and having that change flow into  
these models.  
""  

--

üôÜ‚Äç‚ôÄÔ∏è
```sql
select * from {{ source('jaffle_shop', 'customers') }}
```
???
""  
We always want to configure and use our source functions to refer to raw data!  
This will ensure the source shows up in our DAG, we can use selection syntax to  
rebuild models coming off of this source, and we can easily reconfigure the  
source if needed in one place.  
""  
---
## Apply configurations at the group level
--

üôÖ‚Äç‚ôÄÔ∏è
```sql
-- models/staging/jaffle_shop/stg_jaffle_shop__customers.sql
{{ config(materialized='view')}}
```
```sql
-- models/staging/jaffle_shop/stg_jaffle_shop__orders.sql
{{ config(materialized='view')}}
```
{% endraw %}

???
""  
Apply configurations at the group level when you can. You can see here that we  
have two staging models, customer and orders, which have the same configuration  
to materialize as a view. [Next Slide]  
""  

---
## Apply configurations at the group level

üôÜ‚Äç‚ôÄÔ∏è
```yml
models:
  jaffle_shop:
    staging:
        +materialized: view

```
???
""  
To apply that configuration at a group level, we would instead  
refer to the folder in our dbt_project.yml. You can see here all models in our  
staging folder in the jaffle_shop project will be materialized as a view. This  
helps keep configurations concise and targeted for specific scenarios. When a  
configuration doesn't fit a group-level specification, you would then specify  
the configuration within the model itself for the override.  
""  
  
[Teacher Notes:]  
In our experience when configurations aren't applied at the group level first,  
we tend to see a lot of configurations that don't or shouldn't apply.  
Having the configuration at the top of every model can cause onboarding developers  
to copy and paste just because they see the configuration on everything. By  
applying at the group level, it tailors one-off configurations to specific  
use cases, and prompts developers to ask the right questions (i.e, "any reason  
why this model is configured as a table when the rest are views?").  
---

# non-dbt code

???
""  
What about things that aren't in a .sql or .yml file?  
""  
--

i.e. the code in your repo that dbt doesn't use (but humans do)!

???
""  
This means the code that dbt doesn't use, but humans do! Such as.. [Next Slide]  
""  
---
## Improve your README

A README can help answer:
- How do I get started with this project?
.dense-text[
    * Links to dbt Getting Started instructions
    * Who to contact to get database access
    * Snippets of SQL for a superuser to set up a new user
    * A sample `profiles.yml` file if using the CLI ([example](https://github.com/fishtown-analytics/dbt-init/blob/master/starter-project/sample.profiles.yml))
    * A rough orientation of the project (e.g. which folder does what)
]
- How can I contribute to this project?
.dense-text[
    * Code conventions to follow, e.g. [SQL conventions](https://github.com/fishtown-analytics/corp/blob/master/dbt_coding_conventions.md) and [git conventions](https://github.com/fishtown-analytics/corp/blob/master/git-guide.md)
]

???
""  
The README in your repository - This contains information on what the project is  
and how to contribute. Things like.. [Read slide bullet points]  
""  

[Teacher Note:]  
Many of these are links to our start project script, so include extra jinja  
  
You can pause here to show an example of the README. You can click cmd+click on  
the link to open it in a new tab, or you can navigate to one of our other  
project's readme's such as the [Rapid Onboarding Readme](https://github.com/dbt-labs/rapid-onboarding-exemplar)  
Template, which includes dropdowns for various development setups.  
---
.center[
<img src="/ui/img{{page.id}}/example-readme.png" style="width: 80%;">
]

.caption[
  [Example](https://github.com/clrcrl/dbt-learn-ccarroll/), [Source](https://github.com/fishtown-analytics/dbt-init/tree/master/starter-project)
]
---
## Add a PR template
PR templates help you write better PRs (and are great tools for reviewers!)
* Use headers to prompt someone to fill in the right information
* Checklists are also useful
---
.center[
<img src="/ui/img{{page.id}}/example-pr-template.png" style="width: 80%;">
]

.caption[
  [Example PR template](https://github.com/fishtown-analytics/dbt-init/blob/master/starter-project/.github/pull_request_template.md)
]
.caption[
  [Guide for adding a PR template in GitHub](https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests/creating-a-pull-request-template-for-your-repository)
]
---
class: subtitle, center, middle
# üßò‚Äç‚ôÄÔ∏è [Much better!](https://github.com/fishtown-analytics/dbt-learn-demo-v2/pull/6)

{% include options/last_slide.html %}
