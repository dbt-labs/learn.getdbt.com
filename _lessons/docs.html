---
layout: presentation
title: Docs
estimated_teaching_time: 30
teaching_method: live demo + slides. Questions encouraged.
working_session: true
---

class: title, center, middle
# Docs

---

# Why is documentation important?

_Low quality research manifests as an environment of knowledge cacophony,
where teams only read and trust research that they themselves created._
- Chetan Sharma and Jan Overgoor, [Scaling Knowledge at Airbnb](
https://medium.com/airbnb-engineering/scaling-knowledge-at-airbnb-875d73eff091)

&nbsp;

_If you don't know, now you know._
- Notorious B.I.G., "Juicy"

---

class: subtitle, middle, center
## _How is knowledge documented and maintained at your company?_

---

# Our favorite metaphor

* Analytics engineers are librarians.
* Documentation is the card catalog.
* The goal is to empower analyst-researchers.
--

* _The libarian and the card catalog do not replace each otherâ€”they reinforce and enable each other!_

### Analytics is the organization of an organization's information.

---

class: subtitle, middle, center

## dbt docs

???
not docs.getdbt.com, though those are also great

---

### Adding descriptions

Descriptions go in `.yml` files in your `models/` directory. They can be applied to models, sources, and columns.

{% raw %}

.left-column[
.denser-text[

```yml
version: 2

models:
  - name: fct_orders
    description: One record per order
    columns:
      - name: order_id
        tests:
          - unique
          - not_null

      - name: status
        description: "{{ doc('order_status') }}"
        tests:
          - accepted_values:
              values: ['placed', 'shipped', 'completed', 'return_pending', 'returned']

      - name: amount
        description: Amount in USD
```
]
]

.right-column[
.denser-text[

```yml
version: 2

sources:
  - name: jaffle_shop
    description: A replica of the postgres database
    database: raw
    tables:
      - name: orders
        description: One record per order

        columns:
          - name: id
            tests:
              - unique
              - not_null

          - name: status
            description: "{{ doc('order_status') }}"
            tests:
              - accepted_values:
                  values: ['placed', 'shipped', 'completed', 'return_pending', 'returned']

```

]
]

--

What's the `{{ doc('order_status') }}`?

---

### Example for sources


### `docs` blocks

`docs` blocks allow you to write long-form descriptions. They go in `.md` files in your `models/` directory, and need the `{% docs('my_doc') %}` and `{% enddocs %}` tags.

```md
{% docs order_status %}
One of the following values:

| status         | definition                                                 |
|----------------|------------------------------------------------------------|
| placed         | Order placed but note yet shipped                          |
| shipped        | Order has been shipped but hasn't yet been delivered       |
| completed      | Order has been received by customers                       |
| return_pending | Customer has indicated they would like to return this item |
| returned       | Item has been returned                                     |

{% enddocs %}

```

{% endraw %}

---

class: center, middle
# [Voila !](https://www.getdbt.com/mrr-playbook/#!/model/model.acme.mrr)

---

## dbt CLI
```bash
dbt docs generate
dbt docs serve
```

## dbt Cloud
<img src="/ui/img{{page.id}}/job-config-gen-docs.png" style="width: 90%; float: left;">

---

# Our strong opinions!

Given:
* Code is _surface area_. Testing and documentation are _coverage_.
* Untested, undocumented code _cannot be trusted_. In some sense, it is worse
than having no code at all.

Therefore:
* Data documentation that seeks to accurately describe data transformation _must_
be updated as part of the same workflow as the transformation logic it seeks to
describe. If the two are separate, documentation will _always_ lag behind.


---

class: subtitle

# Questions?

{% include options/next_presentation.html %}
